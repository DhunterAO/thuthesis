% !TeX root = ../main.tex

\chapter{区块链技术背景介绍}

本章主要介绍区块链系统特点，相关密码技术以及分布式共识协议。根据新节点的加入是否需要授权认证，区块链系统主要分为许可链和非许可链两类。区块链系统中大量运用了哈希函数、非对称加密体系、数字签名等密码学技术。分布式共识协议主要介绍了传统的分布式共识协议以及工作量证明共识协议。

\section{区块链系统}

区块链技术旨在不可信的开放网络中，维护一个安全可信、不可篡改的公共账本，并以此为基础构建电子交易、访问控制等应用系统。根据新节点的加入是否需要授权认证，区块链系统可以分为许可链和非许可链两大类。非许可链通常也称为公有链，不限制节点的加入或退出，任何节点可以访问链上数据、发布交易、以及参与链上数据的记录，甚至可以尝试发布不合法消息，攻击网络中的其他节点。许可链指区块链网络中节点 的加入网络、记录账本等操作需要经过特定的授权许可与认证。许可链系统又可以根据系统参与方的数量分为联盟链与私有链，其中联盟链由多方组织加入同一区块链网络中，共同维护区块链账本，记录并执行链上合约，多方组织可以通过一致的账本建立起联盟成员之间的信任。而私有链通常由一个参与方负责创建和维护，主要用于记录和管理内部数据，增强数据的安全性、可追溯性。

本文对比许可链和非许可链两类区块链系统在准入限制、参与方数量、采用的共识算法、应用场景等方面的区别，并总结如表\ref{tab:classification} 所示。 

\begin{table}[htb]
  \centering
  \begin{minipage}[t]{1\linewidth}
  \caption[模板文件]{区块链系统分类}
  \label{tab:classification}
    \begin{tabularx}{\linewidth}{lXX}
      \toprule[1.5pt]
      {\heiti 名称} & {\heiti 非许可链} & {\heiti 许可链} \\\midrule[1pt]
		准入限制  & 无准入限制,任意节点可以随时加入或者退出 & 有准入限制,准入限制由整个联盟的节点商议后制定 \\
		参与方数量  & 较多 & 较少 \\  
		共识算法  & POW, POS等共识算法 & BFT类分布式共识算法 \\  
		区块链性能  & 较低 & 较少 \\  
		应用场景	 & 密码货币交易系统 & 公司间合同，公司内事务管理 \\  
		典型应用  & Bitcoin, Ethereum & HyperLedger, Coco \\
      \bottomrule[1.5pt]
    \end{tabularx}
  \end{minipage}
\end{table}

\section{密码学基础}

区块链系统中引入大量的密码学技术提供安全性、可信性等密码学性质，并以此作为区块链价值的底层保障。目前主要有哈希算法、非对称加密体制、数字签名、布尔集合、密码累加器、同态加密、零知识证明、安全多方计算等密码学技术用于区块链系统。本章主要介绍广泛应用的哈希算法，非对称加密以及数字签名。

\subsection{哈希函数}
\label{subsec:hash}

哈希函数，通常也称散列函数，是一种将任意长度的输入转换为固定长度的输出的函数。哈希函数具有以下密码学特性：
\begin{enumerate}
\item 单向性：从输入计算输出很简单，但在不知道输入的情况下，通过输出计算出输入是计算上不可行的；
\item 输出的随机性：即算法输出的每一位数据在统计学意义上都符合随机分布；
\item 雪崩效应：对输入的任何一点修改，都会导致输出的大量变化；
\item 抗碰撞性：找到两个具有相同的输出的不同输入，是计算上不可行的。
\end{enumerate}

\begin{figure}
\centering  
\includegraphics [width=400pt]{figures/hashchain.png}
\caption{区块链数据结构}
\label{fig:hashchain}
\end{figure}

正是由于上述重要特性，哈希算法被广泛应用于消息认证码、随机数产生、错误校正与检测等领域，而在区块链系统中，哈希算法主要用于检查数据是否被篡改，提供工作量证明，构造存在性证明这几个用途。区块链账本数据根据时间顺序组织成了若干个区块，一定时间内新发生的事务数据存储在一个新区块里，每一个区块都包含了上一个区块的哈希值，具体组织结构如图\ref{fig:hashchain}所示。

这一结构可以保障，如果区块链中任意区块里的数据被篡改，那么该区块的哈希值与后一区块记录的哈希值不相等。因此，区块链上的任何历史数据改动都能被检测。节点只需要存储最新区块的哈希值，即可通过计算检验历史上所有区块中的数据是否被篡改。

\begin{figure}
  \centering%
  \subcaptionbox{默克尔树数据结构\label{fig:merkle-tree}}
    {\includegraphics[width=150pt]{figures/merkle-tree.png}}%
  \hspace{2em}%
  \subcaptionbox{存在性证明\label{fig:merkle-proof}}
      {\includegraphics[width=150pt]{figures/merkle-proof.png}}
  \caption{默克尔树数据结构及存在性证明}
  \label{fig:merkle}
\end{figure}

而在每个区块中，哈希函数用于构建默克尔树，即哈希二叉树。如图\ref{fig:merkle-tree}所示，所有事务的哈希值通过二叉树结构进行哈希计算，最终计算得到根哈希值。该数据结构保证，任意事务数据的修改，都会影响到根哈希值。因此区块头中只需要存储根哈希值，就可以验证该区块中所有事务是否被篡改。

当用户需要通过根哈希值验证某事务是否在某区块中时，不需要验证该区块中所有事务数据，只需要由存储所有数据的节点提供该事务到根哈希值的路径上所有相关数据。如图\ref{fig:merkle-proof}所示，当用户希望验证事务3是否存储在区块中，只需要验证“事务3”，“哈希2”，“哈希01”这几个数据是否能通过哈希函数得到根哈希值。由哈希函数的抗碰撞性可以保证，证明节点不能提供虚假数据计算出同样的根哈希值。

\subsection{非对称密码体制和数字签名}

密码体制主要分为对称密码体制和非对称密码体制。简单来说，对称密码体制指加密算法中使用的加密密钥和解密算法中使用的解密密钥是相同的密钥，或者解密密钥能通过加密密钥计算得到。而非对称密码体制中，这两者不同，并且解密密钥不能通过加密密钥计算得到。

\begin{figure}[H]
\centering	
\includegraphics [width=400pt,height=100pt]{figures/sym-crypto.png}
\caption{对称密码体制的基本模型}
\label{fig:sym-crypto}
\end{figure}

如图\ref{fig:sym-crypto}所示，对称密码体制中，发送者先使用密钥和加密算法将明文加密为密文，然后传输密文给接收方，接收方使用解密算法和相同的密钥将密文解密回原始的明文。因为加密和解密算法使用的密钥需要相同，消息发送方和接收方必须在密文传输前通过安全信道进行密钥传输。因此对称密码体制面临密钥分配问题，目前主要通过通信双方直接进行密钥传输或者密钥分配中心进行密钥分发进行。然而实际的传输信道安全性并不理想，密钥在传输过程中被暴露的风险很大，增加了系统的脆弱性。另一方面，在有多个用户的网络中，任何两个用户之间都需要共享加密密钥。当网络中用户$n$很大时，需要管理的密钥数目为$C_n^2$，复杂度近似O($n^2$)。当有一个新用户加入时，需要产生$n$个秘密的密钥，并秘密分发给$n$个用户。

\begin{figure}[H]
\centering	
\includegraphics [width=400pt,height=115pt]{figures/asym-crypto.png}
\caption{非对称密码体制的基本模型}
\label{fig:asym-crypto}
\end{figure}

1976年，W.Diffie和M.Hellman在IEEE Trans.on Information刊物上发表了“ New Direction in Cryptography”文章，提出了“非对称密码体制“的概念，开创了密码学研究的新方向。如图\ref{fig:asym-crypto}所示，非对称密码体制中，密钥分为成对的加密密钥和解密密钥，其中加密密钥公开，解密密钥保密。公开的密钥可以作为用户的个人身份，由公开的加密密钥无法推导相应的解密密钥。因此即使将加密密钥公开也不会暴露解密密钥，不会损害密码的安全。因此，通信双方可以通过不安全的信道交换公钥，然后用对方的公钥对消息进行加密并传输，达到在不安全的信道上保密传输的效果。解决了对称密码体制中需要安全信道的问题，同时在密钥管理上也极大降低了网络中需要管理的密钥数量，从对称密码体制的$C_n^2$降低到$n$。对称密码体制与非对称密码体制在密钥分发、密钥管理等方面的区别主要如表\ref{tab:sym-asym}所示。

\begin{table}[htb]
  \centering
  \begin{minipage}[t]{1\linewidth}
  \caption{对称密码体制与非对称密码体制的区别}
  \label{tab:sym-asym}
    \begin{tabularx}{\linewidth}{lXX}
      \toprule[1.5pt]
      {\heiti 功能} & {\heiti 对称密码体制} & {\heiti 非对称密码体制} \\\midrule[1pt]
		密钥分发  & 需要事先进行安全的密钥分发 & 不需要事先进行安全的密钥分发，公钥可以在不安全的信道上传输 \\
		密钥管理  & 每个用户需要保存n个不同密钥用于与其他n个用户通信。当有新用户加入时，每个用户都需要和新用户共享一个新密钥，整个系统中需要存储O($n^2$)个密钥 & 每个用户只需要存储自己的公钥和私钥，整个系统中只需要存储O(n)个密钥 \\
		数字签名  & 不支持数字签名功能 & 支持数字签名功能 \\  
		性能  & 加密算法和解密算法简单，加解密速度较快 & 加密算法和解密算法需要进行复杂的数学运算，速度较慢 \\  
		安全性  & 安全性来源于混淆和置换 & 安全性通常基于数学难问题，部分假设未证明 \\ 
      \bottomrule[1.5pt]
    \end{tabularx}
  \end{minipage}
\end{table}

数字签名技术，通常也称为电子签名，指通过算法对数字消息进行处理得出签名。计算得到的数字签名同样具有手写签名的两大特性：可验证性和防伪造性。具体来说，数字签名具备以下特性：

\begin{enumerate}
 \item 任何人可以验证数字签名是否由消息的发送方生成。
 \item 任何人不能伪造发送方的数字签名，这也意味着发送方不能抵赖自己生成的数字签名。
 \item 任何人可以验证数字签名是否匹配发送的消息，因此可以验证消息从发送到接受过程中是否被篡改。对整个消息生成数字签名过于复杂，因此通常先对消息计算哈希值，然后生成哈希值的数字签名用于验证。
\end{enumerate}

在区块链领域，每个用户都可以通过特定算法独立生成任意多账户，即公私钥对。当用户发起事务时，需要用私钥生成事务数据的数字签名。当该事务涉及其他用户时，使用特定用户公钥生成的地址。

\section{共识协议}

多个节点为了达成关于某些数据的一致性，需要共同运行的共识协议进行保障。在传统的分布式领域，所有节点由同一公司或者组织运行，因此各节点的安全性、可信性都能得到保障，主要考虑节点出现共识模块关闭、消息网络延迟、节点宕机等异常情况。如果攻击者入侵控制系统中某些节点，则可以通过故意构造错误数据，以及对系统中不同节点发送不同的信息破坏共识过程。这类被入侵节点通常称为拜占庭节点，能抵抗部分拜占庭节点的共识协议称为拜占庭容错共识协议。

传统的分布式共识协议都是基于可信身份的投票机制，各节点知道当前共识系统中的节点数量以及各节点公钥，可以验证信息来源。而在区块链领域中，节点不受中心化组织管理，可以自由加入和退出。攻击者可以构建任意多的身份参与投票，因此在公有链领域需要采用无身份背书的共识协议，目前主要采用工作量证明共识协议。

\subsection{传统分布式共识协议}
\label{subsec:traditional-consensus}

传统分布式共识协议主要根据能否抵抗拜占庭节点，分为拜占庭容错共识协议和非拜占庭容错共识协议两类。本节主要介绍非拜占庭容错共识协议Paxos和Raft，以及拜占庭容错共识协议PBFT。

Leslie Lamport于1989年首次发布Paxos共识协议，Paxos协议通过处理器在协议中的角色来描述处理器的动作:客户端、接受者、提议者、学习者和领导者。在具体实现中，单个节点可能同时扮演一个或多个角色。

\begin{description}
  \item \textbf{[客户端]} 客户端向分布式系统发出请求，并等待响应。例如，对分布式文件服务器中的文件的读/写请求。
  \item \textbf{[接收方(选民)]} 接受方充当协议的容错“存储器”，接收方集合称为Quorums。发送给接收方的任何消息必须发送到接收方全体集合。从接收方接收到的任何消息都将被忽略，除非从集合中的每个接收方接收到相同的消息。
  \item \textbf{[提案方]} 提案方主张客户端请求，试图说服接收方同意它，并充当协调者，在冲突发生时推动协议继续，保障共识的活性。
  \item \textbf{[学习方]} 学习方充当协议的备份节点。一旦接收方同意了客户端的请求，学习者就可以采取行动执行请求并向客户端发送响应。为了提高系统的可用性，可以添加额外的学习者。
  \item \textbf{[领导方]} 系统达成一致需要领导方的提案并且协同。许多节点可能同时认为自己是领导者，但协议只保证在最终选出一个领导方时才能继续。如果两个节点都认为它们是领导方，可能会通过不断提出相互冲突的更新来阻止协议。然而，在这种情况下，仍能保障系统安全性。
\end{description}

一轮成功的Paxos共识从分布式系统中某节点接收到客户端发起的请求开始，到系统对该请求达成一致性结果结束。主要分为提议和接受两个阶段，每个阶段各包含两个步骤。

\begin{description}
  \item \textbf{[提议阶段]} 提议阶段包含准备和承诺两个阶段
  \begin{enumerate}
    \item 准备：收到客户端请求的节点充当提案方创建一个消息，我们称之为“准备”，它的编号为数字$n$。$n$不是要提议的值，它只是由提案方(发送给接收方)唯一标识这个初始消息的数字。编号$n$必须大于此提案方在先前的任何“准备”消息中所使用的编号。然后，它将包含$n$的“准备”消息发送给接收方集合。“准备”消息只包含数字n，不包含客户端发送的请求信息。
    \item 承诺：任何接收方都在等待来自任何提案方的“准备”消息。如果接收方收到一条“准备”消息，接收方检查编号$n$。如果$n$大于此前从任意提案方接受的所有提案编号，接受方必须返回一个“承诺”消息给提案方，并且忽略此后接收到的所有编号小于$n$的“准备”消息。如果接收方此前已接受某提案，则需要将包含接受的提案编号$m$和对应的值$w$的“提案”消息返回给提案方。
否则，如果n小于或等于接收方此前从任何提案方收到的提案编号，接收方可以忽略所收到的提案。
  \end{enumerate}

  \item \textbf{[接受阶段]} 提议阶段包含准备和承诺两个阶段
  \begin{enumerate}
    \item 接受请求：如果提案方收到来自大多数接收方集合的“承诺”消息，则需要为其“提案”消息设置一个值$v$，通常这个值表示从客户端接收到的请求数据。如果任何接收方曾经接受过提议，在提议阶段的承诺步骤中，会将接受的“提案”消息返回给提案方。提案方从接收到的所有“提案”消息中找出最大编号的提案，假设该提案的值为$z$，则需要将“提案”消息的值设为$z$。如果没有一个接收方返回“提案”消息，那么提案方可以选择自己的提案值$x$。提案者在选定值后，向接收方集合发送一个“接受”消息，包含编号$n$和提案值$v$，其中编号$n$与此前的“准备”消息一致。
    \item 接受：当接受者从提议者那里收到一条“接受”消息($n,v$)，如果该节点已在提议阶段的承诺步骤中发出承诺只考虑编号大于$n$的提案时，则拒绝该消息。如果接收方尚未承诺，则该节点记录“接受”消息中的值$v$作为接受值。并将“接受”消息发送到提案方和每一个学习方。一个接受者可以接受多个提议，这可能发生在另一个提案方不知道正在决定的新值，并用更大的编号$m$开始新一轮。在这种情况下，接受者仍可以承诺并稍后接受新提议的值。这些提案可能导致接收方集合记录不同的值。然而，Paxos协议将保证接受方最终会同意某一相同的值。
  \end{enumerate}
\end{description}

2014年，Ongaro等人提出了Raft共识协议，简化Paxos协议的工作流程。相较于Paxos共识协议中各节点可以随时充当领导方发起提案，Raft协议首先通过领导选举推选出一个固定的节点担任领导方，当该节点故障时再做更换。在Raft协议中主要包含领导方，追随者和候选人三种角色。

\begin{description}
  \item \textbf{[领导方]} 领导方负责将记录备份给所有追随者，也需要不断发送心跳信息给追随者表明自己处于正常运行的状态。
  \item \textbf{[追随者]} 追随者负责接收并记录领导方发送的消息，同时通过心跳信息监听领导方的运行情况，一旦出现宕机等情况则转为候选人角色。
  \item \textbf{[候选人]} 当追随者发现领导方出现宕机等故障，将进入候选人角色，发起领导选举。
\end{description}

Raft协议的共识过程主要包含领导选举和记录备份两个部分，

\begin{description}
  \item \textbf{[领导选举]} 当系统开始运行Raft共识协议或者当现有的领导方出现故障时，所有参与节点需要选出一个新的领导方。系统共识的每一轮周期可能持续任意长的时间，都从领导选举开始。如果成功选出领导方，则本轮周期由该领导方负责后续的步骤，直到该领导方出现宕机等故障结束。如果选举失败，则开始新一轮周期，重新选举领导方。

  每轮领导选举由候选人发起。如果在周期$n$中，某节点在一段时间内没有收到领导者的心跳信息，那么该节点将成为候选人。它进入下一轮周期$n+1$，同时并向所有其他节点发送消息请求它们投票。当该节点收集到超过一半的投票，则成为新的领导方。如果在投票过程中，候选人节点接收到别的节点发出的消息，并且消息包含的周期值不低于$n+1$，则该节点停止选举并转为追随者。

  每个节点在每轮周期中只会进行一次投票，采用先到先得的方式。因此如果多个候选人同时请求投票，则可能所有候选人都收集不到超过一半的投票。在进入候选的时候，每个候选人会启动一个随机的定时器，定时器结束时进入下一轮周期，再次发起投票请求。

  \item \textbf{[记录备份]} 在选出领导后，领导方需要负责记录的备份。该领导方接受客户端发送的请求，每个请求包含一条指令。当请求作为一个新条目添加到领导方的日志之后，每个请求都作为“新增条目”消息转发给追随者。如果追随者出现宕机等情况不可用，领导方将不断地重新发送“新增条目”消息，直到日志条目最终被所有追随者存储。一旦领导方从大多数追随者收到条目已经被复制的确认，领导方会将该条目应用于本地的状态机，该请求处于“承诺”状态。同时也会提交领导方的日志中存在的所有条目。一旦追随者得知日志条目处于“承诺”状态，就将该条目应用到其本地状态机。
\end{description}

Paxos共识协议和Raft共识协议只能解决节点宕机和网络通信等故障异常，不能抵抗拜占庭节点的攻击。实用的拜占庭容错(PBFT，Practical Byzantine Fault Tolerance)共识协议于1999年提出，减少了此前拜占庭容错共识协议的时间和通信复杂度。PBFT共识协议主要包含“主节点”和“从节点”。PBFT协议的一次正常共识过程分为以下五个阶段：
 
\begin{figure}
\centering  
\includegraphics [width=400pt]{figures/pbft.png}
\caption{PBFT共识协议的正常流程}
\label{fig:pbft}
\end{figure}

\begin{enumerate}
  \item 客户端向系统中节点发送请求，接受到请求的节点将该请求转发给当前的主节点。
  \item 在预准备阶段，主节点将“预准备”消息广播给所有备份节点，包含请求的编号，请求内容等信息。
  \item 如果从节点接受“预准备”消息，则进入准备阶段。节点将“准备”消息广播给所有其他节点，包括主节点。
  \item 某节点一旦接收到不少于2f+1个“准备”消息，则进入“承诺”阶段，向其他节点广播“承诺”消息。
  \item 如果节点收到了相同请求的f+1个“承诺”消息，可以认为系统对该请求达成共识，将该请求记录到日志并作出对应的状态修改。客户端从接收到的所有回复中找出相同的大部分作为正确的回复。
\end{enumerate}

\subsection{工作量证明共识协议}
\label{subsec:work-proof}

在区块链领域，尤其在公有链网络中，节点可以自由加入或退出网络。需要采用无身份状态的共识协议。目前，公有链项目广泛使用比特币系统提出的工作量证明共识协议及类似协议。本节我们主要介绍比特币系统提出的工作量证明共识协议，以太坊项目改进的幽灵协议，以及Conflux项目进一步提出的Conflux共识协议。

工作量证明技术基于哈希函数的单向性、输出随机性和雪崩效应，要求用户通过修改消息后附带的$nonce$字段，达到整个消息哈希值在特定范围内。由于哈希函数的单向性，用户只能通过不断修改$nonce$值进行尝试。由哈希值每一位的独立随机性可以估计，该用户为了计算出合法的$nonce$值需要的计算工作量。而计算出合法的nonce值后，验证该输入是否合法只需要一次哈希计算。

比特币项目巧妙地将这一技术和第\ref{subsec:hash}节中提到的哈希链技术结合构建工作量共识协议。比特币系统中，打包新区块的节点需要在完成事务数据的组装后，不断修改nonce值，使得区块头的哈希值达到难度要求。当不同区块同时计算出合法的新区块时，网络中的节点并不能对选择哪一个区块达成共识，因此各节点可以选择任意区块并在之后进一步打包新区块，当某一分支积累的区块超过其他分支后，所有节点将放弃较短的分支，达成一致选择最长的分支。这也就是比特币系统的最长链法则。节点采用算力投票的方式达成共识，选择某一分支的节点算力之和越大，则该分支产生新区块的概率越高。

当达成一致后，除了最长链以外的分支区块都会被抛弃，这给了攻击者进行“双花攻击”的机会。攻击者通过分叉，将同一笔比特币先后发送给两个不同的账户，由于分叉的存在，在每个分支上交易都是合法的，这即是“双花攻击”。当攻击者拥有的算力超过正常节点的算力之和，即超过全网50\%的算力，攻击者可以创建分支超过正常节点维护的分支，这也就是“51\%算力攻击”。这一安全阈值并不绝对，原因就在于正常节点之间存在分叉，在投票恢复一致的过程中，正常节点的算力会分配到各分支上，此时恶意节点超过最长链不需要超过50\%的算力。分支越多，攻击者需要的算力越少，系统安全性越低。

最长链原则共识的分叉问题制约了其性能。为了提升区块链系统的性能，必须减少新区块的时间间隔，或者增大区块大小，包含更多交易。这两者都会导致新区块在网络中传播的时间相较于计算出块的时间比减小，进而导致更容易出现分支并且更难达成一致，这将导致系统安全性降低。

为了解决性能瓶颈，以太坊项目提出了幽灵协议，该协议将最长链共识原则改为最大子树共识原则。幽灵协议从创世块出发，在每次遇到分叉时，不断选择权重最大的子树作为下一个区块，每个子树的权重由该子树包含的所有区块难度和决定。即使正常节点之间出现算力分叉，也在同一个子树下进行计算新区块，可以共同抵抗攻击者构造的新分支，保障了系统安全性。

以太坊提出的最大子树共识原则利用了分叉区块的计算工作量，用于抵抗分叉攻击，提升系统安全性。但最终的链上数据只采用了一条链上的数据，除此以外的数据都被抛弃。这样可以保障整个区块链数据的一致性，避免状态矛盾。为了进一步提升系统性能，conflux协议在此基础上进一步利用了分叉块中未冲突的交易。conflux共识协议增加对分叉区块中的交易进行验证的步骤，通过对整个树状结构进行时期的划分，然后将各时期中与主链不矛盾的交易都认为合法交易，提升系统性能。

